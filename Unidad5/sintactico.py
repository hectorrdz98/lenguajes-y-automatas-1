import pickle
import re

fileName = 'program1.hd'                       # Code file

import os
os.system('python lexico.py ' + fileName)
print()

# Load data from lexico

file = open('lexicAnalisis.data', 'rb')
lexic = pickle.load(file)

# Colors for terminal

textColors = {
    'reset': '\033[0m',
    'green': '\033[32m',
    'red': '\033[31m',
    'yellow': '\033[93m',
    'cyan': '\033[36m',
    'orange': '\033[33m',
    'blue': '\033[34m',
    'purple': '\033[35m',
    'pink': '\033[95m',
    'bold': '\033[01m',
    'underline': '\033[04m',
}

import os           
os.system('color')          # Activate color mode in terminal


# Turing model

turing = {}

with open('syntax.tr') as file:
    for line in file:
        if line != '' and line != '\n':
            comment = re.split('#', line)
            if comment[0] != '':
                thing = comment[0]
                thing = re.split(r'\s+', thing)
                if thing[0] in turing:
                    turing[thing[0]].append([
                        thing[1], thing[2], thing[3], thing[4]
                    ])
                else:
                    turing[thing[0]] = []
                    turing[thing[0]].append([
                        thing[1], thing[2], thing[3], thing[4]
                    ])


# Errors

errors = {
    'errorSQ': 'You forgot to close a single quote',
    'errorDQ': 'You forgot to close a double quote',
    'errorStrOp': 'Invalid operation with string',
    'errorFNClose': 'You forgot to close the parameter declaration',
    'errorInvOp': 'Invalid usage of operator',
    'errorInvVarDec': 'Invalid variable declaration',
    'errorInvVarDecUn': 'Unknown thing assign to variable',
    'errorInvOp': 'Unknown operator',
    'errorFInvCall': 'Invalid function call, missing ( params )',
    'errorFInvCall3': 'Invalid function call',
    'errorInvExp': 'Invalid expression',
    'errorIfInvCall': 'Invalid if condicion, missing ( params )',
    'errorIfInvLogic': 'Invalid logical condition',
    'errorIfElseInvCall': 'Invalid if/else call, required { }',
    'errorElse': 'Invalid else call, missing an if before',
    'errorBreak': 'Invalid usage of break, you need to be on a while or for loop',
    'errorUn': "Sorry, I don't understand what your are telling"
}

# Success states from syntax.tr

successStates = [
    'reading'
]

currentL = 0                # Current lexic index that is on analisis
actState = 'reading'        # Current state
goodSyntax = True           # Good syntax
programmerError = True      # Error generated by this program

groupedStack = []           # Stack with Parenthesis and Braces
lastOpGrouped = ""          # Last Op Parenthesis or Brace

groupedStackFunc = []       # Stack with Parenthesis and Braces for functions
groupedStackIfElse = []     # Stack with Parenthesis for ifs

validLogical = False        # Check if a expresion is a valid logical expretion
terms = []                  # Terms on if logical exp

littleBracesGrouped = []    # Flag that tells if last thing was a valid if/while/for
contLittleBracesClosed = 0  # Max limit for else to follow

isWhile = False             # Chack if if or while

funcForVariable = False     # Flag for variable assign of function

debug = True                # If we want debug data

while True:

    # Check if we reach the limits of lexic data
    if currentL >= len(lexic):
        break
    if currentL < 0:
        print('{}{}Woooops! Negative lexic index? Whaaaaaaat?{}'.format(
            textColors['bold'], textColors['red'], textColors['reset']
        ))
        goodSyntax = False
        break

    # Activate flags
    if actState == 'ifContinue':
        typeToPut = 'If'
        if isWhile:
            typeToPut = 'While'
        littleBracesGrouped.append([True, False, typeToPut])
    if groupedStackIfElse != [] and actState == 'checkIf2':
        terms.append(lexic[currentL][0])

    # Debugs
    if debug:
        print('\n\n{}{}actState:{} {}'.format(
            textColors['bold'], textColors['blue'], textColors['reset'], actState
        ))
        print('currentLexic: {}'.format(lexic[currentL]))
        if groupedStack != []:
            print('groupedStack: {} --> {}'.format(lastOpGrouped, groupedStack))    
        if groupedStackFunc != []:
            print('groupedStackFunc: {}'.format(groupedStackFunc))
        if groupedStackIfElse != []:
            print('groupedStackIfElse: {}'.format(groupedStackIfElse))
        if littleBracesGrouped != []:
            print('littleBracesGrouped: {}'.format(littleBracesGrouped))
        if terms != []:
            print('terms: {}'.format(terms))

    # If the actual state is in the turing model
    if actState in turing:
        flag = False
        # For each path in the turing[actState]
        for path in turing[actState]:
            if path[0] == lexic[currentL][0]  or path[0] == '*':
                if debug:
                    print('Got with {}'.format(path))

                # If function is for variable assign of not
                if actState == 'reading' and lexic[currentL][0] == 'Function':
                    funcForVariable = False
                elif actState != 'reading' and lexic[currentL][0] == 'Function':
                    funcForVariable = True    

                # Activate flags
                if actState == 'reading' and lexic[currentL][0] != 'BreakLine':
                    if lexic[currentL][0] != 'Else':
                        if lexic[currentL][0] != 'CloBrace':
                            if len(littleBracesGrouped) > 0:
                                lastIf = littleBracesGrouped[len(littleBracesGrouped) - 1]
                                if lastIf[0] and lastIf[1]:
                                    littleBracesGrouped.pop()
                        else:
                            if contLittleBracesClosed > 1:
                                if len(littleBracesGrouped) > 0:
                                    lastIf = littleBracesGrouped[len(littleBracesGrouped) - 1]
                                    if lastIf[0] and lastIf[1]:
                                        littleBracesGrouped.pop()
                                contLittleBracesClosed = 0

                # Move left of right
                if path[2] == 'r':
                    currentL += 1
                if path[2] == 'l':
                    currentL -= 1

                # Change actual state
                actState = path[3]
                flag = True
                break
        
        # If not a valid path in turing
        if not flag:
            print('\n{}{}Not a valid path for {} in {}{}'.format(
                textColors['bold'], textColors['red'], 
                lexic[currentL], actState,
                textColors['reset']
            ))
            goodSyntax = False
            break

    # If the state is not in turing
    else:

        # If checkGrouped
        if actState == 'checkGrouped':

            if not funcForVariable:
                if lexic[currentL][0] == 'BreakLine':
                    currentL += 1
                    actState = 'reading'
                    continue
                else:
                    actState = 'errorInvExp'
                    continue

            if lastOpGrouped != 'OpParenthesis':
                currentL += 1
                actState = 'reading'
            else:
                actState = 'errorInvExp'
            continue

        # If stackGrouped
        if actState == 'stackGrouped':
            
            currentLexicGrouped = lexic[currentL]

            if lexic[currentL][0] == 'OpParenthesis' or lexic[currentL][0] == 'OpBrace':
                lastOpGrouped = lexic[currentL][0]
                currentL += 1
                actState = 'variableValue'
                groupedStack.append(currentLexicGrouped[0])

            elif lexic[currentL][0] == 'CloParenthesis' or lexic[currentL][0] == 'CloBrace':
                
                # If correct stack, last ( and actual )
                if lastOpGrouped == 'OpParenthesis' and lexic[currentL][0] == 'CloParenthesis':
                    groupedStack.pop(len(groupedStack)-1)
                    
                    # Update lastOpGrouped
                    if len(groupedStack) > 0:
                        lastOpGrouped = groupedStack[len(groupedStack)-1]
                    else:
                        lastOpGrouped = ''

                    currentL += 1
                    actState = 'variableENDL'
                
                else:
                    actState = 'errorInvExp'

            continue
        
        # If stackFunctionParams
        if actState == 'stackFunctionParams':
            if lexic[currentL][0] == 'OpParenthesis':
                groupedStackFunc.append(lexic[currentL][0])
                currentL += 1
                actState = 'checkFunction2'
                continue
            
            elif lexic[currentL][0] == 'CloParenthesis':
                if len(groupedStackFunc) > 0:
                    groupedStackFunc.pop()
                    if groupedStackFunc == []:
                        if funcForVariable:
                            actState = 'variableENDL'
                        else:
                            actState = 'checkGrouped'
                    else:
                        actState = 'checkFuncENDL'
                    currentL += 1
                else:
                    actState = 'errorInvExp'
                continue

        # If compStackFunctionParams
        if actState == 'compStackFunctionParams':
            if len(groupedStackFunc) > 0:
                groupedStackFunc.pop()
                if groupedStackFunc == []:
                    actState = 'variableENDL'
                    currentL += 1
                else:
                    actState = 'errorInvExp'
            else:
                actState = 'errorInvExp'
            continue

        # If stackIfParams
        if actState == 'stackIfParams':
            if lexic[currentL][0] == 'OpParenthesis':
                groupedStackIfElse.append(lexic[currentL][0])
                currentL += 1
                actState = 'checkIf2'
                continue
            elif lexic[currentL][0] == 'CloParenthesis':
                if validLogical or len(terms) == 1:
                    if len(groupedStackIfElse) > 0:
                        lastStackParen = groupedStackIfElse.pop()
                        if groupedStackIfElse == []:
                            actState = 'ifContinue'
                            validLogical = False
                        else:
                            if lastStackParen == 'OpParenthesis':
                                actState = 'ifContinue'
                                validLogical = False
                            else:
                                actState = 'checkIfENDL'
                        currentL += 1
                        terms = []
                    else:
                        actState = 'errorInvExp'
                else:
                    actState = 'errorIfInvLogic'
                continue
        
        # If stackBrace
        if actState == 'stackBrace':
            if lexic[currentL][0] == 'OpBrace':
                groupedStackIfElse.append(lexic[currentL][0])
                currentL += 1
                actState = 'reading'
                continue
            elif lexic[currentL][0] == 'CloBrace':
                if len(littleBracesGrouped) > 0:
                    lastIf = littleBracesGrouped[len(littleBracesGrouped) - 1]
                    if lastIf[0] == True and lastIf[1] == False:
                        lastIf[1] = True
                        contLittleBracesClosed += 1
                if len(groupedStackIfElse) > 0:
                    lastStackBrace = groupedStackIfElse.pop()
                    if lastStackBrace == 'OpBrace':
                        currentL += 1
                        actState = 'reading'
                        continue
                    else:
                        actState = 'errorIfElseInvCall'
                        continue
                else:
                    actState = 'errorIfElseInvCall'
                    continue
                


        # If we have to activate the validLogical
        if actState == 'activateLogicalExp':
            validLogical = True
            actState = 'posibleEqual'
            continue
        if actState == 'activateLogicalExp2':
            validLogical = True
            actState = 'checkIfENDLForced'
            continue

        # If we got an else
        if actState == 'preCheckElse':
            if not isWhile:
                if len(littleBracesGrouped) > 0:
                    lastIf = littleBracesGrouped[len(littleBracesGrouped) - 1]
                    if lastIf[0] and lastIf[1]:
                        littleBracesGrouped.pop()
                        currentL += 1
                        actState = 'checkElse'
                        continue
                    else:
                        actState = 'errorElse'
                        continue
                else:
                    actState = 'errorElse'
                    continue
            else:
                actState = 'errorElse'
                continue

        # If we got an and / or
        if actState == 'checkValidAndOr':
            if validLogical or len(terms) == 1:
                currentL += 1
                validLogical = False
                terms = []
                actState = 'checkIf2'
            else:
                actState = 'errorIfInvLogic'
            continue

        # If we got an while
        if actState == 'isWhile':
            isWhile = True
            actState = 'checkIf'
            continue
        
        # If we got an if
        if actState == 'isIf':
            isWhile = False
            actState = 'checkIf'
            continue

        # Check if we are in for or while for valid usage of break
        if actState == 'checkValidBreak':
            actState = 'errorBreak'
            for littleBrace in littleBracesGrouped:
                if littleBrace[2] == 'While' or littleBrace[2] == 'For':
                    currentL += 1
                    actState = 'reading'
                    break
            continue




        # Check if state is error state
        if actState in errors:
            # Load codes lines for debugging line in error
            codeLines = []
            with open(fileName, encoding='utf-8') as file:
                for line in file:
                    codeLines.append(line)

            print('\n{}{}{} in line {}{}{} :  {}{}{}'.format(
                textColors['bold'], textColors['red'], errors[actState], 
                textColors['orange'], lexic[currentL][4] + 1, textColors['red'],
                textColors['orange'], codeLines[lexic[currentL][4]], 
                textColors['reset']
            ))
            programmerError = False
            goodSyntax = False
            break

        print('\n{}{}The state is not in turing{}'.format(
            textColors['bold'], textColors['red'], textColors['reset']
        ))
        goodSyntax = False
        break


codeLines = []
with open(fileName, encoding='utf-8') as file:
    for line in file:
        codeLines.append(line)

# If not syntax errors
if goodSyntax and actState in successStates:
    if groupedStack == []:
        if groupedStackFunc == []:
            if groupedStackIfElse == []:
                print('\n{}{}Nice! No syntax errors{}'.format(
                    textColors['bold'], textColors['green'], textColors['reset']
                ))
            else:
                print('\n{}{}{} in some part of the code.{}'.format(
                    textColors['bold'], textColors['red'], 
                    errors['errorIfElseInvCall'], textColors['reset']
                ))
        else:
            print('\n{}{}{} in some part of the code.{}'.format(
                textColors['bold'], textColors['red'], 
                errors['errorFInvCall'], textColors['reset']
            ))
    else:
        print('\n{}{}{} in some part of the code.{}'.format(
            textColors['bold'], textColors['red'], 
            errors['errorInvExp'], textColors['reset']
        ))

else:
    # If programmer error
    if programmerError:
        print('{}{}Oh no... My bad...{}'.format(
            textColors['bold'], textColors['red'], textColors['reset']
        ))

