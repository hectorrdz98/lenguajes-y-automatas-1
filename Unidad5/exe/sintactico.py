import pickle
import re

fileName = 'program1.hd'                       # Code file

import os
os.system('python lexico.py ' + fileName)
print()

# Load data from lexico

file = open('lexicAnalisis.data', 'rb')
lexic = pickle.load(file)

# Colors for terminal

textColors = {
    'reset': '\033[0m',
    'green': '\033[32m',
    'red': '\033[31m',
    'yellow': '\033[93m',
    'cyan': '\033[36m',
    'orange': '\033[33m',
    'blue': '\033[34m',
    'purple': '\033[35m',
    'pink': '\033[95m',
    'bold': '\033[01m',
    'underline': '\033[04m',
}

import os           
os.system('color')          # Activate color mode in terminal


# Turing model

turing = {}

with open('syntax.tr') as file:
    for line in file:
        if line != '' and line != '\n':
            comment = re.split('#', line)
            if comment[0] != '':
                thing = comment[0]
                thing = re.split(r'\s+', thing)
                if thing[0] in turing:
                    turing[thing[0]].append([
                        thing[1], thing[2], thing[3], thing[4]
                    ])
                else:
                    turing[thing[0]] = []
                    turing[thing[0]].append([
                        thing[1], thing[2], thing[3], thing[4]
                    ])


# Errors

errors = {
    'errorSQ': 'You forgot to close a single quote',
    'errorDQ': 'You forgot to close a double quote',
    'errorStrOp': 'Invalid operation with string',
    'errorFNClose': 'You forgot to close the parameter declaration',
    'errorInvOp': 'Invalid usage of operator',
    'errorInvVarDec': 'Invalid variable declaration',
    'errorInvVarDecUn': 'Unknown thing assign to variable',
    'errorInvOp': 'Unknown operator',
    'errorFInvCall': 'Invalid function call, missing ( params )',
    'errorFInvCall3': 'Invalid function call',
    'errorInvExp': 'Invalid expression'
}

# Success states from syntax.tr

successStates = [
    'reading'
]

currentL = 0                # Current lexic index that is on analisis
actState = 'reading'        # Current state
goodSyntax = True           # Good syntax
programmerError = True      # Error generated by this program

groupedStack = []           # Stack with Parenthesis and Braces
lastOpGrouped = ""          # Last Op Parenthesis or Brace

groupedStackFunc = []

funcForVariable = False

while True:

    # Check if we reach the limits of lexic data
    if currentL >= len(lexic):
        break
    if currentL < 0:
        print('{}{}Woooops! Negative lexic index? Whaaaaaaat?{}'.format(
            textColors['bold'], textColors['red'], textColors['reset']
        ))
        goodSyntax = False
        break


    print('\n\n{}{}actState:{} {}'.format(
        textColors['bold'], textColors['blue'], textColors['reset'], actState
    ))
    print('currentLexic: {}'.format(lexic[currentL]))

    if groupedStack != []:
        print('\ngroupedStack: {} --> {}\n'.format(lastOpGrouped, groupedStack))
    
    if groupedStackFunc != []:
        print('\ngroupedStackFunc: {}\n'.format(groupedStackFunc))

    if actState in turing:
        flag = False
        for path in turing[actState]:
            if path[0] == lexic[currentL][0]  or path[0] == '*':
                print('Got with {}'.format(path))

                # If function if for variable assign of not
                if actState == 'reading' and lexic[currentL][0] == 'Function':
                    funcForVariable = False
                elif actState != 'reading' and lexic[currentL][0] == 'Function':
                    funcForVariable = True    

                if path[2] == 'r':
                    currentL += 1
                if path[2] == 'l':
                    currentL -= 1

                actState = path[3]
                flag = True
                break
        
        # If not a valid path in turing
        if not flag:
            print('\n{}{}Not a valid path for {} in {}{}'.format(
                textColors['bold'], textColors['red'], 
                lexic[currentL], actState,
                textColors['reset']
            ))
            goodSyntax = False
            break

    # If the state is not in turing
    else:

        # If checkGrouped
        if actState == 'checkGrouped':

            if not funcForVariable:
                if lexic[currentL][0] == 'BreakLine':
                    currentL += 1
                    actState = 'reading'
                    continue
                else:
                    actState = 'errorInvExp'
                    continue

            if lastOpGrouped != 'OpParenthesis':
                currentL += 1
                actState = 'reading'
            else:
                actState = 'errorInvExp'
            continue

        # If stackGrouped
        if actState == 'stackGrouped':
            
            currentLexicGrouped = lexic[currentL]

            if lexic[currentL][0] == 'OpParenthesis' or lexic[currentL][0] == 'OpBrace':
                lastOpGrouped = lexic[currentL][0]
                currentL += 1
                actState = 'variableValue'
                groupedStack.append(currentLexicGrouped[0])

            elif lexic[currentL][0] == 'CloParenthesis' or lexic[currentL][0] == 'CloBrace':
                
                # If correct stack, last ( and actual )
                if lastOpGrouped == 'OpParenthesis' and lexic[currentL][0] == 'CloParenthesis':
                    groupedStack.pop(len(groupedStack)-1)
                    
                    # Update lastOpGrouped
                    if len(groupedStack) > 0:
                        lastOpGrouped = groupedStack[len(groupedStack)-1]
                    else:
                        lastOpGrouped = ''

                    currentL += 1
                    actState = 'variableENDL'
                
                else:
                    actState = 'errorInvExp'

            continue
        
        # If stackFunctionParams
        if actState == 'stackFunctionParams':
            if lexic[currentL][0] == 'OpParenthesis':
                groupedStackFunc.append(lexic[currentL][0])
                currentL += 1
                actState = 'checkFunction2'
                continue
            
            elif lexic[currentL][0] == 'CloParenthesis':
                if len(groupedStackFunc) > 0:
                    groupedStackFunc.pop()
                    if groupedStackFunc == []:
                        if funcForVariable:
                            actState = 'variableENDL'
                        else:
                            actState = 'checkGrouped'
                    else:
                        actState = 'checkFuncENDL'
                    currentL += 1
                else:
                    actState = 'errorInvExp'
                continue

        # Check if state is error state
        if actState in errors:
            # Load codes lines for debugging line in error
            codeLines = []
            with open(fileName, encoding='utf-8') as file:
                for line in file:
                    codeLines.append(line)

            print('\n{}{}{} in line {}{}{} :  {}{}{}'.format(
                textColors['bold'], textColors['red'], errors[actState], 
                textColors['orange'], lexic[currentL][4] + 1, textColors['red'],
                textColors['orange'], codeLines[lexic[currentL][4]], 
                textColors['reset']
            ))
            programmerError = False
            goodSyntax = False
            break

        print('\n{}{}The state is not in turing{}'.format(
            textColors['bold'], textColors['red'], textColors['reset']
        ))
        goodSyntax = False
        break


# If not syntax errors
if goodSyntax and actState in successStates:
    print('\n{}{}Nice! No syntax errors{}'.format(
        textColors['bold'], textColors['green'], textColors['reset']
    ))

else:
    # If programmer error
    if programmerError:
        print('{}{}Oh no... My bad...{}'.format(
            textColors['bold'], textColors['red'], textColors['reset']
        ))

